\documentclass[10pt]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{float}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{array}
\usepackage{parskip}

% Setup links
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Serial Bus System Implementation Report},
}

% Code listing style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{verilogstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=verilogstyle}

% ---------------------------------------------------------
% PROJECT VARIABLES (Fill these before compiling)
% ---------------------------------------------------------
\newcommand{\projtitle}{System Serial Bus Design}
\newcommand{\indexno}{Index No}

\newcommand{\memberone}{Thuvaragan S.}
\newcommand{\memberoneid}{210657G}

\newcommand{\membertwo}{Sundarbavan T.}
\newcommand{\membertwoid}{210624E}

\newcommand{\memberthree}{Wijethilaka U.G.P.M.B.}
\newcommand{\memberthreeid}{210724K}

\newcommand{\memberfour}{Member Four}
\newcommand{\memberfourid}{XXXXXXXX}

% ---------------------------------------------------------
% TITLE PAGE
% ---------------------------------------------------------
\begin{document}

\begin{titlepage}
    \centering
    {\Large \textbf{Department of Electronic and Telecommunication Engineering}}\\
    {\Large \textbf{University of Moratuwa, Sri Lanka}}\\	
		
    \vspace{0.5in}
    % Ensure UoM_logo.png is in the same directory
    \includegraphics[width=0.3\textwidth]{UoM_logo.png}\\
    \vspace{0.5in}			
			
    {\Huge \textbf{\projtitle}}\\
        \vspace{0.5in}
        {\Large \textbf{EN4021 - Advanced Digital Systems}}\\
    
    \vspace{1.5in}

    \begin{flushleft} 
        \normalsize
        \textsc{Members:\hfill \indexno}\\[0.2cm]

        \memberone \hfill \memberoneid\\
        \membertwo \hfill \membertwoid\\
        \memberthree \hfill \memberthreeid\\
        % \memberfour \hfill \memberfourid\\
    \end{flushleft}

    \vfill
    
    \vspace{0.5in}
    {\normalsize \textbf{\today}}
\end{titlepage}

% ---------------------------------------------------------
% TABLE OF CONTENTS
% ---------------------------------------------------------
\tableofcontents
\newpage

\section{Overview}

The Serial Bus System is a compact, resource-efficient serial bus designed for FPGA platforms. The implementation reported here targets the Intel Cyclone IV family on the Terasic DE0-Nano board and demonstrates a multi-master multi-slave serial interconnect supporting split transactions and a UART-based bus bridge for inter-bus communication.

The system uses a 1-bit serial data path and an explicit request/grant arbitration scheme with split-transaction support to allow long-latency peripherals to relinquish the bus while the rest of the system continues operation.

\subsection{Architecture}
The implemented design supports:
\begin{itemize}
    \item Two masters (Master 1: high priority, Master 2: low priority/Bridge Master).
    \item Three slaves (Slave 1 and Slave 2 local BRAM-backed slaves; Slave 3 acting as a Bus Bridge).
    \item Central Bus Interconnect containing: Arbiter, Address Decoder, Master/Slave multiplexers and control logic.
    \item Split transaction support for slaves that require long response latency (specifically Slave 3 in Bridge mode).
    \item UART-based bus bridge to enable inter-FPGA communication.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{diagrams/full_architecture.png}
    \caption{Full System Architecture}
    \label{fig:full_arch}
\end{figure}

\subsection{Key Features}
\begin{itemize}
    \item \textbf{Multi-Master Support:} Two masters with deterministic priority arbitration (M1 prioritized). Master 2 serves as the interface for remote commands via UART.
    \item \textbf{Split Transactions:} Slaves that cannot respond immediately (like the Bridge Slave) can assert a \texttt{ssplit} line. The arbiter tracks the split owner and issues a \texttt{split\_grant} when the slave becomes ready, allowing other masters to use the bus in the interim.
    \item \textbf{Bus Bridge:} UART-based bridge supports translation between local serial bus frames and remote bus frames; uses FIFOs to cross clock domains.
    \item \textbf{Resource Efficiency:} Single-bit serial data and compact FSMs reduce LUT/logic usage and routing complexity.
\end{itemize}

\section{Address Allocation}

\subsection{General Address Encoding}
A 16-bit address format is used in the implemented design. The upper bits (typically 4) contain the \textit{Device ID} that selects one of the slaves. The remaining low-order bits index the memory inside the slave.

\subsection{Without Bus Bridge}
When the bridge is not enabled (local-only operation), the address space is partitioned as follows:

\begin{table}[H]
\centering
\caption{Local Address Map}
\begin{tabular}{@{}llll@{}}
\toprule
\textbf{Device ID} & \textbf{Slave} & \textbf{Size} & \textbf{Address Range} \\ \midrule
0000 & Slave 1 & 2 KB & 0x0000 -- 0x07FF \\
0001 & Slave 2 & 4 KB & 0x1000 -- 0x1FFF \\
0010 & Slave 3 & 4 KB & 0x2000 -- 0x2FFF \\ \bottomrule
\end{tabular}
\end{table}

\subsection{With Bus Bridge}
When Slave 3 is configured as the bus bridge, addresses mapped into Slave 3's window (0x2000--0x2FFF) are translated and forwarded to a remote bus via UART. The bridge aggregates the remote slave memory and exposes it through this window.

\section{Master Port}

\subsection{Purpose and role}
The Master Port module provides the interface between a local master device and the serial bus. It serializes addresses and data (MSB/LSB ordering as designed), asserts bus requests and reacts to grants, and handles split/resume handshake.

\subsection{Block Diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{diagrams/master_port.png}
    \caption{Master Port}
\end{figure}

\subsection{I/O Description}
\begin{table}[H]
\centering
\caption{Master Port I/O}
\begin{tabular}{@{}p{3cm} p{1.5cm} p{9cm}@{}}
\toprule
Signal & Dir & Description \\ \midrule
\texttt{daddr[15:0]} & Input & 16-bit address from master device \\
\texttt{dwdata[7:0]} & Input & 8-bit write data from master device \\
\texttt{drdata[7:0]} & Output & 8-bit read data returned to master device \\
\texttt{dvalid} & Input & Master asserts to request a transaction \\
\texttt{dready} & Output & Port ready for new transaction (IDLE) \\
\texttt{dmode} & Input & 0=Read, 1=Write \\
\texttt{mwdata} & Output & Serial bit stream to bus (address/data) \\
\texttt{mrdata} & Input & Serial bit received from a slave \\
\texttt{mmode} & Output & Serial mode to bus (0=Read, 1=Write) \\
\texttt{mvalid} & Output & Serial valid signal pointing to bus \\
\texttt{svalid} & Input & Valid signal from slave (during read) \\
\texttt{mbreq} & Output & Bus request line to arbiter \\
\texttt{mbgrant} & Input & Bus grant from arbiter \\
\texttt{msplit} & Input & Indicates current transaction is split \\
\texttt{ack} & Input & Acknowledge from address decoder \\ \bottomrule
\end{tabular}
\end{table}

\subsection{State Diagram and Behaviour}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{diagrams/state/005_master_port.png}
    \caption{Master Port State Machine}
    \label{fig:master_state}
\end{figure}

The Master FSM acts as the initiator of all transactions. As shown in Figure \ref{fig:master_state}, the operation proceeds as follows:
\begin{itemize}
    \item \textbf{IDLE}: The master waits for a valid request signal (\texttt{dvalid}) from the core logic.
    \item \textbf{REQ}: Upon request, it asserts \texttt{mbreq} and waits in this state until the Arbiter grants access (\texttt{mbgrant}).
    \item \textbf{SADDR}: The master serializes the 4-bit Device Address (MSB-first) to select the target slave.
    \item \textbf{WAIT}: It waits for the Address Decoder to assert \texttt{ack}, confirming the slave is present and ready.
    \item \textbf{ADDR}: If acknowledged, it serializes the 12-bit Memory Address (LSB-first).
    \item \textbf{WDATA / RDATA}: Depending on the mode, it either transmits write data (WDATA) or waits to receive read data (RDATA).
    \item \textbf{SPLIT}: If the slave asserts \texttt{msplit} (e.g., Bus Bridge waiting for UART), the master enters the SPLIT state and releases the bus (de-asserts \texttt{mbreq}), allowing other masters to use it. It remains here until the Arbiter re-grants the bus via \texttt{mbgrant}.
\end{itemize}

\section{Slave Port}

\subsection{Purpose}
The Slave Port module deserializes incoming address/data, controls a local BRAM (or a peripheral), and serializes read data back to the requesting master. It handles the \texttt{ssplit} protocol for high-latency operations.

\subsection{Block Diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{diagrams/slave_port.png}
    \caption{Slave Port}
\end{figure}

\subsection{I/O Description}
\begin{table}[H]
\centering
\caption{Slave Port I/O}
\begin{tabular}{@{}p{3cm} p{1.5cm} p{9cm}@{}}
\toprule
Signal & Dir & Description \\ \midrule
\texttt{swdata} & Input & Serial stream from the active master \\
\texttt{srdata} & Output & Serial read data bitstream to the master \\
\texttt{mvalid} & Input & Valid indicates valid bits coming from master \\
\texttt{sready} & Output & Indicates slave ready to accept new transaction \\
\texttt{svalid} & Output & Read-data valid signal \\
\texttt{ssplit} & Output & Slave asserts to request split \\
\texttt{split\_grant} & Input & Arbiter grants resumed access for split owner \\
\texttt{smemaddr} & Output & Address to the local memory/peripheral \\
\texttt{smemrdata} & Input & Read data from memory/peripheral \\
\texttt{smemwen} & Output & Memory write enable \\
\texttt{smemren} & Output & Memory read enable \\ \bottomrule
\end{tabular}
\end{table}



\subsection{State Diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{diagrams/state/001_slave+port.png}
    \caption{Slave Port State Machine}
    \label{fig:slave_state}
\end{figure}

The Slave Port FSM (Figure \ref{fig:slave_state}) manages deserialization and memory access:
\begin{itemize}
    \item \textbf{IDLE}: Waits for the \texttt{mvalid} signal indicating the start of a transaction.
    \item \textbf{ADDR}: Deserializes the incoming address bits into a register.
    \item \textbf{SREADY}: Once the address is received, it asserts \texttt{sready} to the local memory controller to latch the address/data.
    \item \textbf{WDATA}: If writing, it deserializes the data bits.
    \item \textbf{RDATA}: If reading, it serializes the data from memory back to the bus.
    \item \textbf{SPLIT}: For the Bridge Slave, it may enter this state to signal the Arbiter that the response is pending (UART latency).
\end{itemize}

\section{Arbiter}

\subsection{Overview}
The arbiter serializes access to the shared serial bus, giving Master 1 priority over Master 2. It also manages split transactions, tracking the split-owner and re-granting the bus when the slave is ready.

\subsection{I/O Description}
\begin{table}[H]
\centering
\caption{Arbiter I/O}
\begin{tabular}{@{}p{3cm} p{1.5cm} p{9cm}@{}}
\toprule
Signal & Dir & Description \\ \midrule
\texttt{breq1} & Input & Bus request from Master 1 (High Priority) \\
\texttt{breq2} & Input & Bus request from Master 2 (Low Priority) \\
\texttt{bgrant1} & Output & Grant signal to Master 1 \\
\texttt{bgrant2} & Output & Grant signal to Master 2 \\
\texttt{split\_grant} & Output & Signal to all masters that split phase is ending \\
\texttt{sready1/2} & Input & Ready signals from Slaves 1 and 2 \\
\texttt{sreadysp} & Input & Ready signal from Split Slave (S3) \\
\texttt{ssplit} & Input & Split request signal from Slave 3 \\
\texttt{msplit1/2} & Output & Indicates to masters that transaction is split \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Block Diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{diagrams/arbiter.png}
    \caption{Arbiter}
\end{figure}

\subsection{State Machine}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{diagrams/state/003_arbiter.png}
    \caption{Arbiter State Machine}
    \label{fig:arbiter_state}
\end{figure}

The Arbiter uses a priority-based FSM (Figure \ref{fig:arbiter_state}) to manage bus ownership:
\begin{itemize}
    \item \textbf{IDLE}: Checks for requests. M1 has strict priority over M2.
    \item \textbf{M1 / M2}: Grants the bus to the respective master.
    \item \textbf{Split Handling}: If a transaction splits, the Arbiter remembers the "Split Owner". It allows the non-owner to use the bus (IDLE state) but prevents them from accessing the specific slave involved in the split. When the slave signals completion (\texttt{split\_grant}), the Arbiter re-grants the bus to the original owner.
\end{itemize}

\section{Address Decoder}

\subsection{Purpose}
The address decoder samples the serial device ID bits and asserts \texttt{ssel} and \texttt{ack} to select the correct slave. It validates the address against the map.

\subsection{I/O Description}
\begin{table}[H]
\centering
\caption{Address Decoder I/O}
\begin{tabular}{@{}p{3cm} p{1.5cm} p{9cm}@{}}
\toprule
Signal & Dir & Description \\ \midrule
\texttt{mwdata} & Input & Serial data stream from Master (contains address) \\
\texttt{mvalid} & Input & Valid signal from Master \\
\texttt{ack} & Output & Acknowledge signal to Master \\
\texttt{ssel[1:0]} & Output & Slave Select lines (Binary encoded) \\
\texttt{mvalid1/2/3} & Output & Routed valid signal to selected slave \\
\texttt{sready1/2/3} & Input & Ready status from slaves \\
\texttt{ssplit} & Input & Split request input \\
\texttt{split\_grant} & Input & Split grant input from Arbiter \\ \bottomrule
\end{tabular}
\end{table}

\subsection{Block Diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{diagrams/decoder.png}
    \caption{Address Decoder}
\end{figure}

\subsection{State Diagram}
\begin{figure}[H]
    \centering
    \includegraphics[width=1\linewidth]{diagrams/state/004_address_decoder.png}
    \caption{Address Decoder State Machine}
    \label{fig:decoder_state}
\end{figure}

The Address Decoder FSM (Figure \ref{fig:decoder_state}) synchronizes with the Master's addressing phase:
\begin{itemize}
    \item \textbf{IDLE}: Ready for start of frame.
    \item \textbf{ADDR}: Receive 4-bit Device ID.
    \item \textbf{CONNECT}: Validates the ID. If valid (Device 0, 1, or 2) and the slave is ready, it asserts \texttt{ack}.
    \item \textbf{WAIT}: Holds the connection open for the duration of the master's validity signal.
\end{itemize}

\section{Bus Interconnect}

\subsection{Module}
The \texttt{bus\_m2\_s3.v} module instantiates the arbiter, decoder, and multiplexers. It defines the point-to-point routing between the active master (selected by Arbiter) and active slave (selected by Decoder).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{diagrams/bus.png}
    \caption{Bus Interconnect}
\end{figure}

\subsection{I/O Description}
\begin{table}[H]
\centering
\caption{Bus Interconnect (Top Level) I/O}
\begin{tabular}{@{}p{3cm} p{1.5cm} p{9cm}@{}}
\toprule
Signal & Dir & Description \\ \midrule
\texttt{m1\_rdata} & Output & Serial read data to Master 1 \\
\texttt{m1\_wdata} & Input & Serial write data/addr from Master 1 \\
\texttt{m1\_mbreq} & Input & Request from Master 1 \\
\texttt{m1\_mbgrant} & Output & Grant to Master 1 \\
\texttt{m2\_*} & In/Out & Similar interface for Master 2 \\
\texttt{s1\_wdata} & Output & Serial write data/addr to Slave 1 \\
\texttt{s1\_rdata} & Input & Serial read data from Slave 1 \\
\texttt{s3\_ssplit} & Input & Split signal from Slave 3 \\ \bottomrule
\end{tabular}
\end{table}

\section{Bus Bridge}

\subsection{Bus Bridge Master}
The Bridge Master listens for UART commands from a remote system and issues requests to the local bus. It uses a FIFO to buffer incoming commands (transiting from UART baud clock to Bus clock).

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{diagrams/bus_bridge_master.png}
    \caption{Bus Bridge Master}
\end{figure}

\subsection{I/O Description}
\begin{table}[H]
\centering
\caption{Bus Bridge Master I/O}
\begin{tabular}{@{}p{3cm} p{1.5cm} p{9cm}@{}}
\toprule
Signal & Dir & Description \\ \midrule
\texttt{u\_rx} & Input & UART Receive line (Commands from remote) \\
\texttt{u\_tx} & Output & UART Transmit line (Responses to remote) \\
\texttt{mwdata} & Output & Serial data to bus \\
\texttt{mrdata} & Input & Serial data from bus \\
\texttt{mbreq} & Output & Bus Request \\
\texttt{lmem\_*} & In/Out & Interface to local BRAM \\ \bottomrule
\end{tabular}
\end{table}

\subsection{State Machine Logic}
The Bus Bridge Master relies on a pipelined control flow rather than a single FSM state diagram. Its operation logic is as follows:
\begin{itemize}
    \item \textbf{Command Input}: Incoming UART bytes are deserialized and pushed into a FIFO buffer.
    \item \textbf{Bus Transaction}: A controller monitors the FIFO. When data is available, it initiates a Master Port transaction by asserting \texttt{dvalid} and providing the address/data.
    \item \textbf{Response Forwarding}: For read operations, the controller waits for the Master Port to return valid data (\texttt{drdata}) and then triggers the UART transmitter to send this byte back to the remote host.
\end{itemize}

\subsection{Bus Bridge Slave}
The Bus Bridge Slave forwards local bus transactions to the remote system via UART. For reads, it uses the split transaction mechanism.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{diagrams/bus_bridge_slave.png}
    \caption{Bus Bridge Slave}
\end{figure}

\subsection{I/O Description}
\begin{table}[H]
\centering
\caption{Bus Bridge Slave I/O}
\begin{tabular}{@{}p{3cm} p{1.5cm} p{9cm}@{}}
\toprule
Signal & Dir & Description \\ \midrule
\texttt{swdata} & Input & Serial data from master \\
\texttt{srdata} & Output & Serial data to master \\
\texttt{u\_tx} & Output & UART Transmit (Forward to remote) \\
\texttt{u\_rx} & Input & UART Receive (Response from remote) \\
\texttt{ssplit} & Output & Split signal (Asserted during UART latency) \\
\texttt{lmem\_*} & In/Out & Interface to local BRAM \\ \bottomrule
\end{tabular}
\end{table}

\subsubsection{Bridge Slave State Machine}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{diagrams/state/002_bus_brige_lsave.png}
    \caption{Bus Bridge Slave Controller FSM}
    \label{fig:bridge_slave_state}
\end{figure}

The Bridge Slave controller handles the complex coordination between the high-speed bus and the slow UART link (Figure \ref{fig:bridge_slave_state}):
\begin{itemize}
    \item \textbf{WSEND / RSEND}: Initiates a UART transmission for Write or Read commands.
    \item \textbf{WBUSY / RBUSY}: Waits for the UART transmitter to complete sending the command frame.
    \item \textbf{RDATA}: For read transactions, it waits here for the response byte from the remote system via UART RX. The \texttt{ssplit} signal is held high during this entire wait time.
    \item \textbf{LOCAL}: Handles direct access to the local BRAM if the address falls within the local range.
\end{itemize}

\section{UART Module}
The system uses a configurable UART for the physical link. It supports 8N1 format and parameterized widths.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\linewidth]{diagrams/uart.png}
    \caption{UART Module Schematic}
\end{figure}

\subsection{I/O Description}
\begin{table}[H]
\centering
\caption{UART Module I/O}
\begin{tabular}{@{}p{3cm} p{1.5cm} p{9cm}@{}}
\toprule
Signal & Dir & Description \\ \midrule
\texttt{data\_input} & Input & Parallel data to transmit \\
\texttt{data\_en} & Input & Enable transmission \\
\texttt{tx} & Output & Serial Transmit line \\
\texttt{rx} & Input & Serial Receive line \\
\texttt{data\_output} & Output & Parallel received data \\
\texttt{ready} & Output & Data received valid signal \\ \bottomrule
\end{tabular}
\end{table}

\section{Timing Analysis Report}
The design was synthesized and timing-analyzed for the Cyclone IV (EP4CE22F17C6) with a 50\,MHz system clock.

\textbf{Timing Summary (Slow 85C Model):}
\begin{itemize}
    \item \textbf{Setup Slack:} 14.222 ns
    \item \textbf{Hold Slack:} 0.292 ns
    \item \textbf{Recovery Slack:} 16.805 ns
    \item \textbf{Removal Slack:} 2.660 ns
\end{itemize}

Given a 50\,MHz clock (20\,ns period) and a setup slack of 14.222\,ns, the design has a significant timing margin.
\[ T_{min} = 20\,\text{ns} - 14.22\, \text{ns} = 5.78\,\text{ns} \]
\[ F_{max} \approx \frac{1}{5.78\,\text{ns}} \approx 173\,\text{MHz} \]

The design easily meets the timing requirements.

\section{Resource Utilization Report}
Resource usage synthesized for the DE0-Nano target (Cyclone IV EP4CE22F17C6):

\begin{table}[H]
\centering
\caption{FPGA Resource Usage (Measured)}
\begin{tabular}{@{}ll@{}}
\toprule
Resource Type & Usage / Total \\ \midrule
\textbf{Total Logic Elements} & \textbf{1,551} / 22,320 (7\%) \\
\quad -- Combinational Functions & 1,255 / 22,320 (6\%) \\
\quad -- Dedicated Logic Registers & 1,077 / 22,320 (5\%) \\
\textbf{Total Registers} & 1,077 \\
\textbf{Total Pins} & 19 / 154 (12\%) \\
\textbf{Total Memory Bits} & 65,536 / 608,256 (11\%) \\
Total PLLs & 0 / 4 (0\%) \\ \bottomrule
\end{tabular}
\end{table}

\noindent Notes:
\begin{itemize}
    \item The memory usage (65,536 bits) corresponds to the instantiated Block RAMs (BRAM) for the slave memories and UART FIFOs.
    \item Logic utilization is low (<10\%), leaving ample room for additional logic or masters.
\end{itemize}

\section{Simulation Results}

\subsection{Verification Strategy}
The verification process followed a bottom-up approach, starting from unit tests for individual modules and progressing to a comprehensive system-level testbench. The verification pyramid strategy was employed:
\begin{enumerate}
    \item \textbf{Unit Tests:} Individual modules (Arbiter, Decoder, Master/Slave Ports) were verified in isolation.
    \item \textbf{Integration Tests:} \texttt{master2\_slave3\_tb.sv} verified the interaction between 2 masters and 3 slaves.
    \item \textbf{System Tests:} Final validation on the DE0-Nano FPGA hardware.
\end{enumerate}

\subsection{Testbench: \texttt{master2\_slave3\_tb.sv}}
The primary integration testbench, \texttt{master2\_slave3\_tb.sv}, was designed to exhaustively test the bus protocol and arbitration logic. It covers the following scenarios:

\begin{itemize}
    \item \textbf{Single Master Access:} Verifies basic read and write transactions from M1 and M2 individually.
    \item \textbf{Simultaneous Access (Arbitration):} Asserts request signals from both masters simultaneously to verify that Master 1 (Higher Priority) is granted access first, followed by Master 2.
    \item \textbf{Split Transactions:} Targets Slave 3 (Bridge/Split-Capable) to verify that the bus is released (\texttt{split} asserted) and re-granted (\texttt{split\_grant}) correctly.
    \item \textbf{Address Decoding:} random addresses are generated to ensure requests are routed to the correct slave (S1, S2, or S3).
    \item \textbf{Resource Conflicts:} Simulates scenarios where one master writes to an address while another attempts to read from it.
\end{itemize}

\subsection{Simulation Results}
The simulation was executed using ModelSim/Questasim. 

\textbf{Summary of Results:}
\begin{itemize}
    \item \textbf{Total Test Iterations:} 20 Loops
    \item \textbf{Transactions per Loop:} 3 (Write, Read, Conflict)
    \item \textbf{Total Transactions Verified:} >60
    \item \textbf{Pass Count:} 60
    \item \textbf{Fail Count:} 0
    \item \textbf{Status:} \textbf{ALL PASS}
\end{itemize}

The simulation confirmed that:
\begin{enumerate}
    \item Master 1 successfully preempts Master 2 during simultaneous requests.
    \item Data is correctly serialized and deserialized (byte-accurate transfers).
    \item Split transactions successfully release the bus, allowing other operations to proceed before the split completes.
    \item No deadlocks occurred during high-contention scenarios.
\end{enumerate}

\newpage
\section*{Appendix - Verilog Source Code}
\addcontentsline{toc}{section}{Appendix - Verilog Source Code}

\subsection*{Master Port (\texttt{master\_port.v})}
\begin{lstlisting}[language=Verilog, caption=Master Port FSM (master\_port.v)]
`timescale 1ns / 1ps

module master_port #(
    parameter ADDR_WIDTH = 16,
    parameter DATA_WIDTH = 8,
    parameter SLAVE_MEM_ADDR_WIDTH = 12
)(
    input clk,
    input rstn,
    
    // Signals connecting to master device
    input  [DATA_WIDTH-1:0] dwdata,
    output [DATA_WIDTH-1:0] drdata,
    input  [ADDR_WIDTH-1:0] daddr,
    input                   dvalid,
    output                  dready,
    input                   dmode,
    
    // Signals connecting to serial bus
    input                   mrdata,
    output reg              mwdata,
    output                  mmode,
    output reg              mvalid,
    input                   svalid,
    
    // Signals to arbiter
    output                  mbreq,
    input                   mbgrant,
    input                   msplit,
    
    // Acknowledgement from address decoder
    input                   ack
);

    localparam SLAVE_DEVICE_ADDR_WIDTH = ADDR_WIDTH - SLAVE_MEM_ADDR_WIDTH;
    localparam TIMEOUT_TIME = 5;
    
    // Internal signals
    reg [DATA_WIDTH-1:0] wdata;
    reg [ADDR_WIDTH-1:0] addr;
    reg                  mode;
    reg [DATA_WIDTH-1:0] rdata;
    reg [7:0] counter, timeout;
    
    // States
    localparam IDLE  = 3'b000,
               ADDR  = 3'b001,
               RDATA = 3'b010,
               WDATA = 3'b011,
               REQ   = 3'b100,
               SADDR = 3'b101,
               WAIT  = 3'b110,
               SPLIT = 3'b111;
    
    reg [2:0] state, next_state, prev_state;
    
    always @(*) begin
        case (state)
            IDLE  : next_state = (dvalid) ? REQ : IDLE;
            REQ   : next_state = (mbgrant) ? SADDR : REQ;
            SADDR : next_state = (counter == SLAVE_DEVICE_ADDR_WIDTH-1) ? WAIT : SADDR;
            WAIT  : next_state = (ack) ? ADDR : ((timeout == TIMEOUT_TIME) ? IDLE : WAIT);
            ADDR  : next_state = (counter == SLAVE_MEM_ADDR_WIDTH-1) ? ((mode) ? WDATA : RDATA) : ADDR;
            RDATA : next_state = (msplit) ? SPLIT : ((svalid && (counter == DATA_WIDTH-1)) ? IDLE : RDATA);
            WDATA : next_state = (counter == DATA_WIDTH-1) ? IDLE : WDATA;
            SPLIT : next_state = (!msplit && mbgrant) ? RDATA : SPLIT;
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            state <= IDLE;
            prev_state <= IDLE;
        end else begin
            prev_state <= state;
            state <= next_state;
        end
    end
    
    assign dready = (state == IDLE);
    assign drdata = rdata;
    assign mmode  = mode;
    assign mbreq  = (state != IDLE);
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            wdata   <= 'b0;
            rdata   <= 'b0;
            addr    <= 'b0;
            mode    <= 0;
            counter <= 'b0;
            mvalid  <= 0;
            mwdata  <= 0;
            timeout <= 'b0;
        end
        else begin
            case (state)
                IDLE : begin
                    counter <= 'b0;
                    mvalid  <= 0;
                    timeout <= 'b0;
                    if (dvalid) begin
                        wdata <= dwdata;
                        addr  <= daddr;
                        mode  <= dmode;
                    end
                end
                
                REQ : begin end
                
                SADDR : begin
                    mwdata <= addr[SLAVE_MEM_ADDR_WIDTH + counter];
                    mvalid <= 1'b1;
                    if (counter == SLAVE_DEVICE_ADDR_WIDTH-1)
                        counter <= 'b0;
                    else
                        counter <= counter + 1;
                end
                
                WAIT : begin
                    mvalid  <= 1'b0;
                    timeout <= timeout + 1;
                end
                
                ADDR : begin
                    mwdata <= addr[counter];
                    mvalid <= 1'b1;
                    if (counter == SLAVE_MEM_ADDR_WIDTH-1)
                        counter <= 'b0;
                    else
                        counter <= counter + 1;
                end
                
                RDATA : begin
                    mvalid <= 1'b0;
                    if (svalid) begin
                        rdata[counter] <= mrdata;
                        if (counter == DATA_WIDTH-1)
                            counter <= 'b0;
                        else
                            counter <= counter + 1;
                    end
                end
                
                WDATA : begin
                    if (prev_state == ADDR && state == WDATA) begin
                        mvalid <= 1'b0;
                        mwdata <= 1'b0;
                    end else begin
                        mwdata <= wdata[counter];
                        mvalid <= 1'b1;
                        if (counter == DATA_WIDTH-1)
                            counter <= 'b0;
                        else
                            counter <= counter + 1;
                    end
                end
                
                SPLIT : begin
                    mvalid <= 1'b0;
                end
            endcase
        end
    end
endmodule
\end{lstlisting}

\subsection*{Slave Port (\texttt{slave\_port.v})}
\begin{lstlisting}[language=Verilog, caption=Slave Port FSM (slave\_port.v)]
`timescale 1ns / 1ps

module slave_port #(
    parameter ADDR_WIDTH = 12,
    parameter DATA_WIDTH = 8,
    parameter SPLIT_EN = 0
)(
    input clk,
    input rstn,
    
    input  [DATA_WIDTH-1:0] smemrdata,
    input                   rvalid,
    output reg              smemwen,
    output reg              smemren,
    output reg [ADDR_WIDTH-1:0] smemaddr,
    output reg [DATA_WIDTH-1:0] smemwdata,
    
    input                   swdata,
    output reg              srdata,
    input                   smode,
    input                   mvalid,
    input                   split_grant,
    output reg              svalid,
    output                  sready,
    output                  ssplit
);

    reg [DATA_WIDTH-1:0] wdata;
    reg [ADDR_WIDTH-1:0] addr;
    wire [DATA_WIDTH-1:0] rdata;
    reg mode;
    reg [7:0] counter;
    
    localparam LATENCY = 4;
    reg [LATENCY-1:0] rcounter;
    
    localparam IDLE   = 3'b000,
               ADDR   = 3'b001,
               RDATA  = 3'b010,
               WDATA  = 3'b011,
               SREADY = 3'b101,
               SPLIT  = 3'b100,
               WAIT   = 3'b110,
               RVALID = 3'b111;
    
    reg [2:0] state, next_state, prev_state;
    
    always @(*) begin
        case (state)
            IDLE   : next_state = (mvalid) ? ADDR : IDLE;
            ADDR   : next_state = (counter == ADDR_WIDTH-1) ? ((mode) ? WDATA : SREADY) : ADDR;
            SREADY : next_state = (mode) ? IDLE : ((SPLIT_EN) ? SPLIT : RVALID);
            RVALID : next_state = (rvalid) ? RDATA : RVALID;
            SPLIT  : next_state = (rcounter == LATENCY) ? WAIT : SPLIT;
            WAIT   : next_state = (split_grant) ? RDATA : WAIT;
            RDATA  : next_state = (counter == DATA_WIDTH * 2) ? IDLE : RDATA;
            WDATA  : next_state = (counter == DATA_WIDTH-1) ? SREADY : WDATA;
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) state <= IDLE;
        else begin
            prev_state <= state;
            state <= next_state;
        end
    end
    
    assign rdata  = smemrdata;
    assign sready = (state == IDLE);
    assign ssplit = (state == SPLIT);
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            wdata    <= 'b0;
            addr     <= 'b0;
            counter  <= 'b0;
            svalid   <= 0;
            smemren  <= 0;
            smemwen  <= 0;
            mode     <= 0;
        end
        else begin
            case (state)
                IDLE : begin
                    counter <= 'b0;
                    svalid  <= 0;
                    smemren <= 0;
                    smemwen <= 0;
                    if (mvalid) begin
                        mode <= smode;
                        addr[counter] <= swdata;
                        counter <= counter + 1;
                    end
                end
                
                ADDR : begin
                    svalid <= 1'b0;
                    if (mvalid) begin
                        addr[counter] <= swdata;
                        if (counter == ADDR_WIDTH-1) counter <= 'b0;
                        else counter <= counter + 1;
                    end
                end
                
                SREADY: begin
                    if (mode) begin
                        smemwen   <= 1'b1;
                        smemwdata <= wdata;
                        smemaddr  <= addr;
                    end else begin
                        smemren  <= 1'b1;
                        smemaddr <= addr;
                    end
                end
                
                RVALID, SPLIT, WAIT: begin
                    smemren <= 1'b1; // Keep read active
                end

                RDATA : begin
                    if (counter < DATA_WIDTH * 2) begin
                        if (counter[0] == 0) begin
                            srdata <= rdata[counter >> 1];
                            svalid <= 1'b0;
                        end else begin
                            svalid <= 1'b1;
                        end
                        smemren <= 1'b1;
                        counter <= counter + 1;
                    end else begin
                        svalid <= 1'b0;
                        smemren <= 1'b0;
                        counter <= 'b0;
                    end
                end
                
                WDATA : begin
                    svalid <= 1'b0;
                    if (mvalid && !(prev_state == ADDR && state == WDATA)) begin
                        wdata[counter] <= swdata;
                        if (counter == DATA_WIDTH-1) begin
                            // smemwen not set here - handled in SREADY
                            counter <= 'b0;
                        end else begin
                            counter <= counter + 1;
                        end
                    end
                end
            endcase
        end
    end
endmodule
\end{lstlisting}

\subsection*{Arbiter (\texttt{arbiter.v})}
\begin{lstlisting}[language=Verilog, caption=Arbiter (arbiter.v)]
`timescale 1ns / 1ps

module arbiter (
    input clk,
    input rstn,
    input breq1,
    input breq2,
    input sready1,
    input sready2,
    input sreadysp,
    input ssplit,
    output bgrant1,
    output bgrant2,
    output msel,
    output reg msplit1,
    output reg msplit2,
    output reg split_grant
);

    wire sready, sready_nsplit;
    reg [1:0] split_owner;
    
    assign sready        = sready1 & sready2 & sreadysp;
    assign sready_nsplit = sready1 & sready2;
    
    localparam NONE = 2'b00, SM1 = 2'b01, SM2 = 2'b10;
    localparam IDLE = 3'b000, M1 = 3'b001, M2 = 3'b010;
    
    reg [2:0] state, next_state;
    
    always @(*) begin
        case (state)
            IDLE : begin
                if (!ssplit) begin
                    if (split_owner == SM1) next_state = M1;
                    else if (breq1 & sready) next_state = M1;
                    else if (split_owner == SM2) next_state = M2;
                    else if (breq2 & sready) next_state = M2;
                    else next_state = IDLE;
                end
                else begin
                    if ((split_owner == SM1) && breq2 && sready_nsplit) next_state = M2;
                    else if ((split_owner == SM2) && breq1 && sready_nsplit) next_state = M1;
                    else next_state = IDLE;
                end
            end
            
            M1 : next_state = (!breq1 | (split_owner == NONE && ssplit)) ? IDLE : M1;
            M2 : next_state = (!breq2 | (split_owner == NONE && ssplit)) ? IDLE : M2;
            
            default: next_state = IDLE;
        endcase
    end
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) state <= IDLE;
        else state <= next_state;
    end
    
    assign bgrant1 = (state == M1);
    assign bgrant2 = (state == M2);
    assign msel    = (state == M2);
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            msplit1      <= 1'b0;
            msplit2      <= 1'b0;
            split_owner  <= NONE;
            split_grant  <= 1'b0;
        end
        else begin
            case (state)
                M1 : begin
                    if (split_owner == NONE && ssplit) begin
                        msplit1     <= 1'b1;
                        split_owner <= SM1;
                        split_grant <= 1'b0;
                    end else if (split_owner == SM1 && !ssplit) begin
                        msplit1     <= 1'b0;
                        split_owner <= NONE;
                        split_grant <= 1'b1;
                    end
                end
                
                M2 : begin
                    if (split_owner == NONE && ssplit) begin
                        msplit2     <= 1'b1;
                        split_owner <= SM2;
                        split_grant <= 1'b0;
                    end else if (split_owner == SM2 && !ssplit) begin
                        msplit2     <= 1'b0;
                        split_owner <= NONE;
                        split_grant <= 1'b1;
                    end
                end
            endcase
        end
    end
endmodule
\end{lstlisting}

\subsection*{Address Decoder (\texttt{addr\_decoder.v})}
\begin{lstlisting}[language=Verilog, caption=Address Decoder (addr\_decoder.v)]
`timescale 1ns / 1ps

module addr_decoder #(
    parameter ADDR_WIDTH = 16,
    parameter DEVICE_ADDR_WIDTH = 4
)(
    input clk, rstn,
    input mwdata, mvalid,
    input ssplit, split_grant,
    input sready1, sready2, sready3,
    output mvalid1, mvalid2, mvalid3,
    output reg [1:0] ssel,
    output ack
);

    reg [DEVICE_ADDR_WIDTH-1:0] slave_addr;
    reg slave_en;
    wire mvalid_out;
    wire slave_addr_valid;
    wire [2:0] sready;
    reg [3:0] counter;
    reg [DEVICE_ADDR_WIDTH-1:0] split_slave_addr;
    
    assign mvalid1 = (ssel == 0) & mvalid_out;
    assign mvalid2 = (ssel == 1) & mvalid_out;
    assign mvalid3 = (ssel == 2) & mvalid_out;
    
    localparam IDLE = 2'b00, ADDR = 2'b01, CONNECT = 2'b10, WAIT = 2'b11;
    reg [1:0] state, next_state;
    
    always @(*) begin
        case (state)
            IDLE    : next_state = (mvalid) ? ADDR : ((split_grant) ? WAIT : IDLE);
            ADDR    : next_state = (counter == DEVICE_ADDR_WIDTH-1) ? CONNECT : ADDR;
            CONNECT : next_state = (slave_addr_valid) ? ((mvalid) ? WAIT : CONNECT) : IDLE;
            WAIT    : next_state = (sready[slave_addr] | ssplit) ? IDLE : WAIT;
            default : next_state = IDLE;
        endcase
    end
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) state <= IDLE;
        else state <= next_state;
    end
    
    assign mvalid_out       = mvalid & slave_en;
    assign sready           = {sready3, sready2, sready1};
    assign slave_addr_valid = (slave_addr < 3) & sready[slave_addr];
    assign ack              = (state == CONNECT) & slave_addr_valid;
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            slave_addr <= 0; slave_en <= 0; counter <= 0; ssel <= 0;
        end
        else begin
            case (state)
                IDLE : begin
                    slave_en <= 0;
                    if (mvalid) begin
                        slave_addr[0] <= mwdata;
                        counter       <= 1;
                    end else if (split_grant) begin
                        slave_addr <= split_slave_addr;
                    end
                end
                ADDR : begin
                    slave_addr[counter] <= mwdata;
                    if (counter == DEVICE_ADDR_WIDTH-1) counter <= 0;
                    else counter <= counter + 1;
                end
                CONNECT : begin
                    slave_en <= 1;
                    ssel     <= slave_addr[1:0];
                end
                WAIT : begin
                    slave_en <= 1;
                    ssel     <= slave_addr[1:0];
                    if (ssplit) split_slave_addr <= slave_addr;
                end
            endcase
        end
    end
endmodule
\end{lstlisting}

\subsection*{Bus Bridge Master (\texttt{bus\_bridge\_master.v})}
\begin{lstlisting}[language=Verilog, caption=Bus Bridge Master (bus\_bridge\_master.v)]
`timescale 1ns / 1ps

module bus_bridge_master #(
    parameter ADDR_WIDTH = 16, 
    parameter DATA_WIDTH = 8,
    parameter SLAVE_MEM_ADDR_WIDTH = 12,
    parameter BB_ADDR_WIDTH = 12,
    parameter UART_CLOCKS_PER_PULSE = 5208,
    parameter LOCAL_MEM_SIZE = 2048,
    parameter LOCAL_MEM_ADDR_WIDTH = 11
)(
    input clk, rstn,
    
    // Serial Bus Interface (as a master)
    input  wire mrdata,
    output wire mwdata,
    output wire mmode,
    output wire mvalid,
    input  wire svalid,

    // Arbiter Interface
    output wire mbreq,
    input  wire mbgrant,
    input  wire msplit,

    // Address Decoder Interface
    input  wire ack,

    // Local Memory Interface
    input  wire                     lmem_wen,
    input  wire                     lmem_ren,
    input  wire [LOCAL_MEM_ADDR_WIDTH-1:0] lmem_addr,
    input  wire [DATA_WIDTH-1:0]    lmem_wdata,
    output wire [DATA_WIDTH-1:0]    lmem_rdata,
    output wire                     lmem_rvalid,

    // Bus Bridge UART Interface
    output wire u_tx,
    input  wire u_rx
);
    localparam UART_RX_DATA_WIDTH = DATA_WIDTH + BB_ADDR_WIDTH + 1;
    localparam UART_TX_DATA_WIDTH = DATA_WIDTH;
    
    reg  [DATA_WIDTH-1:0]    dwdata;
    wire [DATA_WIDTH-1:0]    drdata;
    wire [ADDR_WIDTH-1:0]    daddr;
    reg                      dvalid;
    wire                     dready;
    reg                      dmode;

    reg                              fifo_enq;
    reg                              fifo_deq;
    reg  [UART_RX_DATA_WIDTH-1:0]    fifo_din;
    wire [UART_RX_DATA_WIDTH-1:0]    fifo_dout;
    wire                             fifo_empty;

    reg  [UART_TX_DATA_WIDTH-1:0]    u_din;
    reg                              u_en;
    wire                             u_tx_busy;
    wire                             u_rx_ready;
    wire [UART_RX_DATA_WIDTH-1:0]    u_dout;

    reg  [BB_ADDR_WIDTH-1:0] bb_addr;
    reg                      expect_rdata;
    reg                      prev_u_ready;
    reg                      prev_m_ready;

    master_port #(
        .ADDR_WIDTH(ADDR_WIDTH),
        .DATA_WIDTH(DATA_WIDTH),
        .SLAVE_MEM_ADDR_WIDTH(SLAVE_MEM_ADDR_WIDTH)
    ) master (
        .clk(clk),
        .rstn(rstn),
        .dwdata(dwdata),
        .drdata(drdata),
        .daddr(daddr),
        .dvalid(dvalid),
        .dready(dready),
        .dmode(dmode),
        .mrdata(mrdata),
        .mwdata(mwdata),
        .mmode(mmode),
        .mvalid(mvalid),
        .svalid(svalid),
        .mbreq(mbreq),
        .mbgrant(mbgrant),
        .msplit(msplit),
        .ack(ack)
    );

    fifo #(
        .DATA_WIDTH(UART_RX_DATA_WIDTH),
        .DEPTH(8)
    ) fifo_queue (
        .clk(clk),
        .rstn(rstn),
        .enq(fifo_enq),
        .deq(fifo_deq),
        .data_in(fifo_din),
        .data_out(fifo_dout),
        .empty(fifo_empty)
    );

    uart #(
        .CLOCKS_PER_PULSE(UART_CLOCKS_PER_PULSE),
        .TX_DATA_WIDTH(UART_TX_DATA_WIDTH),
        .RX_DATA_WIDTH(UART_RX_DATA_WIDTH)
    ) uart_module (
        .data_input(u_din),
        .data_en(u_en),
        .clk(clk),
        .rstn(rstn),
        .tx(u_tx),
        .tx_busy(u_tx_busy),
        .rx(u_rx),  
        .ready(u_rx_ready),   
        .data_output(u_dout)
    );

    addr_convert #(
        .BB_ADDR_WIDTH(BB_ADDR_WIDTH),
        .BUS_ADDR_WIDTH(ADDR_WIDTH),
        .BUS_MEM_ADDR_WIDTH(SLAVE_MEM_ADDR_WIDTH)
    ) addr_convert_module (
        .bb_addr(bb_addr),
        .bus_addr(daddr)
    );

    master_memory_bram #(
        .ADDR_WIDTH(LOCAL_MEM_ADDR_WIDTH),
        .DATA_WIDTH(DATA_WIDTH),
        .MEM_SIZE(LOCAL_MEM_SIZE)
    ) local_mem (
        .clk(clk),
        .rstn(rstn),
        .wen(lmem_wen),
        .ren(lmem_ren),
        .addr(lmem_addr),
        .wdata(lmem_wdata),
        .rdata(lmem_rdata),
        .rvalid(lmem_rvalid)
    );

    // UART RX to FIFO
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            fifo_din     <= {UART_RX_DATA_WIDTH{1'b0}};
            fifo_enq     <= 1'b0;
            prev_u_ready <= 1'b0;
        end
        else begin
            prev_u_ready <= u_rx_ready;
            if (u_rx_ready && !prev_u_ready) begin
                fifo_din <= u_dout;
                fifo_enq <= 1'b1;
            end else begin
                fifo_din <= fifo_din;
                fifo_enq <= 1'b0;
            end
        end
    end

    // FIFO to Master Port
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            bb_addr      <= {BB_ADDR_WIDTH{1'b0}};
            dwdata       <= {DATA_WIDTH{1'b0}};
            dmode        <= 1'b0;
            dvalid       <= 1'b0;
            fifo_deq     <= 1'b0;
            expect_rdata <= 1'b0;
        end
        else begin
            if (dready && !fifo_empty && !dvalid) begin
                bb_addr      <= fifo_dout[BB_ADDR_WIDTH-1:0];
                dwdata       <= fifo_dout[BB_ADDR_WIDTH +: DATA_WIDTH];
                dmode        <= fifo_dout[BB_ADDR_WIDTH + DATA_WIDTH];
                dvalid       <= 1'b1;
                fifo_deq     <= 1'b1;
                expect_rdata <= ~fifo_dout[BB_ADDR_WIDTH + DATA_WIDTH];
            end else begin
                dvalid       <= 1'b0;
                fifo_deq     <= 1'b0;
            end
        end
    end

    // Master Port to UART TX
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            u_din        <= {UART_TX_DATA_WIDTH{1'b0}};
            u_en         <= 1'b0;
            prev_m_ready <= 1'b0;
        end
        else begin
            prev_m_ready <= dready;
            if (!prev_m_ready && dready && expect_rdata) begin
                u_din <= drdata;
                u_en  <= 1'b1;
            end else begin
                u_en  <= 1'b0;
            end
        end
    end
endmodule
\end{lstlisting}

\subsection*{Bus Bridge Slave (\texttt{bus\_bridge\_slave.v})}
\begin{lstlisting}[language=Verilog, caption=Bus Bridge Slave (bus\_bridge\_slave.v)]
`timescale 1ns / 1ps

module bus_bridge_slave #(
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = 12,
    parameter UART_CLOCKS_PER_PULSE = 5208,
    parameter LOCAL_MEM_SIZE = 2048,
    parameter BRIDGE_ENABLE = 1
)(
    input clk, rstn,
    
    input  wire swdata,
    input  wire smode,
    input  wire mvalid,
    input  wire split_grant,
    
    output wire srdata,
    output wire svalid,
    output wire sready,
    output wire ssplit,
    
    output wire u_tx,
    input  wire u_rx
);
    localparam UART_TX_DATA_WIDTH = DATA_WIDTH + ADDR_WIDTH + 1;
    localparam UART_RX_DATA_WIDTH = DATA_WIDTH;
    localparam SPLIT_EN = 1'b1;
    localparam LOCAL_ADDR_MSB = ADDR_WIDTH - 1;

    wire [DATA_WIDTH-1:0]    sp_memrdata;
    wire                     sp_memwen;
    wire                     sp_memren;
    wire [ADDR_WIDTH-1:0]    sp_memaddr;
    wire [DATA_WIDTH-1:0]    sp_memwdata;
    reg                      sp_rvalid;
    wire                     sp_ready;
    
    wire                     lmem_wen;
    wire                     lmem_ren;
    wire [ADDR_WIDTH-2:0]    lmem_addr;
    wire [DATA_WIDTH-1:0]    lmem_rdata;
    wire                     lmem_rvalid;

    reg  [UART_TX_DATA_WIDTH-1:0] u_din;
    reg                           u_en;
    wire                          u_tx_busy;
    wire                          u_rx_ready;
    wire [UART_RX_DATA_WIDTH-1:0] u_dout;

    reg  [DATA_WIDTH-1:0] latched_rdata;
    reg  [DATA_WIDTH-1:0] latched_wdata;
    reg  [ADDR_WIDTH-1:0] latched_addr;
    reg                   rdata_received;
    reg                   prev_u_rx_ready;
    reg                   pending_write;
    reg                   pending_read;
    wire                  is_bridge_access;
    wire                  is_local_access;
    
    wire is_bridge_access_now = sp_memaddr[LOCAL_ADDR_MSB] & BRIDGE_ENABLE;
    wire is_local_access_now  = ~sp_memaddr[LOCAL_ADDR_MSB];
    
    assign is_bridge_access = latched_addr[LOCAL_ADDR_MSB] & BRIDGE_ENABLE;
    assign is_local_access  = ~latched_addr[LOCAL_ADDR_MSB];
    
    assign lmem_wen  = sp_memwen & is_local_access;
    assign lmem_ren  = sp_memren & is_local_access;
    assign lmem_addr = sp_memaddr[ADDR_WIDTH-2:0];

    wire sp_split_grant;
    wire sp_ssplit;
    
    slave_port #(
        .ADDR_WIDTH(ADDR_WIDTH),
        .DATA_WIDTH(DATA_WIDTH),
        .SPLIT_EN(SPLIT_EN)
    ) slave (
        .clk(clk), 
        .rstn(rstn),
        .smemrdata(sp_memrdata),
        .rvalid(sp_rvalid),
        .smemwen(sp_memwen), 
        .smemren(sp_memren),
        .smemaddr(sp_memaddr), 
        .smemwdata(sp_memwdata),
        .swdata(swdata),
        .srdata(srdata),
        .smode(smode),
        .mvalid(mvalid),	
        .split_grant(sp_split_grant),
        .svalid(svalid),	
        .sready(sp_ready),
        .ssplit(sp_ssplit)
    );

    slave_memory_bram #(
        .ADDR_WIDTH(ADDR_WIDTH-1),
        .DATA_WIDTH(DATA_WIDTH),
        .MEM_SIZE(LOCAL_MEM_SIZE)
    ) local_mem (
        .clk(clk),
        .rstn(rstn),
        .wen(lmem_wen),
        .ren(lmem_ren),
        .addr(lmem_addr),
        .wdata(sp_memwdata),
        .rdata(lmem_rdata),
        .rvalid(lmem_rvalid)
    );

    uart #(
        .CLOCKS_PER_PULSE(UART_CLOCKS_PER_PULSE),
        .TX_DATA_WIDTH(UART_TX_DATA_WIDTH),
        .RX_DATA_WIDTH(UART_RX_DATA_WIDTH)
    ) uart_module (
        .data_input(u_din),
        .data_en(u_en),
        .clk(clk),
        .rstn(rstn),
        .tx(u_tx),
        .tx_busy(u_tx_busy),
        .rx(u_rx),  
        .ready(u_rx_ready),   
        .data_output(u_dout)
    );

    localparam IDLE=3'b000, WSEND=3'b001, RSEND=3'b010, RDATA=3'b011, LOCAL=3'b100, WBUSY=3'b101, RBUSY=3'b110;
    reg [2:0] state, next_state;

    wire bridge_read_in_progress = (state == RSEND) || (state == RBUSY) || (state == RDATA);
    assign sp_split_grant = bridge_read_in_progress ? (split_grant && rdata_received) : split_grant;
    assign ssplit = sp_ssplit || (bridge_read_in_progress && !rdata_received);

    reg prev_sp_memwen, prev_sp_memren;
    
    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin
            latched_wdata   <= 0; latched_addr <= 0; pending_write <= 0; pending_read <= 0;
            prev_sp_memwen  <= 0; prev_sp_memren <= 0;
        end else begin
            prev_sp_memwen <= sp_memwen;
            prev_sp_memren <= sp_memren;
            
            if (sp_memwen && !prev_sp_memwen && state == IDLE) begin
                latched_wdata <= sp_memwdata;
                latched_addr  <= sp_memaddr;
                if (sp_memaddr[LOCAL_ADDR_MSB] & BRIDGE_ENABLE) pending_write <= 1'b1;
            end else if (sp_memren && !prev_sp_memren && state == IDLE) begin
                latched_addr  <= sp_memaddr;
                if (sp_memaddr[LOCAL_ADDR_MSB] & BRIDGE_ENABLE) pending_read  <= 1'b1;
            end else if (state == WSEND || state == RSEND) begin
                pending_write <= 0; pending_read <= 0;
            end
        end
    end

    reg uart_tx_started;
    always @(posedge clk or negedge rstn) begin
        if (!rstn) uart_tx_started <= 0;
        else if (state == WSEND || state == RSEND) uart_tx_started <= 0;
        else if ((state == WBUSY || state == RBUSY) && u_tx_busy) uart_tx_started <= 1;
        else if (state == IDLE) uart_tx_started <= 0;
    end

    always @(*) begin
        case (state)
            IDLE: begin
                if (pending_write) next_state = WSEND;
                else if (pending_read) next_state = RSEND;
                else if ((sp_memwen || sp_memren) && is_local_access_now) next_state = LOCAL;
                else next_state = IDLE;
            end
            WSEND:  next_state = WBUSY;
            WBUSY:  next_state = (uart_tx_started && !u_tx_busy) ? IDLE : WBUSY;
            RSEND:  next_state = RBUSY;
            RBUSY:  next_state = (uart_tx_started && !u_tx_busy) ? RDATA : RBUSY;
            RDATA:  next_state = (!sp_memren) ? IDLE : RDATA;
            LOCAL:  next_state = (!sp_memwen && !sp_memren) ? IDLE : LOCAL;
            default: next_state = IDLE;
        endcase
    end

    always @(posedge clk or negedge rstn) begin
        if (!rstn) state <= IDLE;
        else state <= next_state;
    end

    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin latched_rdata <= 0; rdata_received <= 0; prev_u_rx_ready <= 0; end
        else begin
            prev_u_rx_ready <= u_rx_ready;
            if (state == IDLE) begin
                rdata_received <= 0; latched_rdata <= 0;
            end else if (state == RDATA && u_rx_ready && !prev_u_rx_ready) begin
                latched_rdata <= u_dout;
                rdata_received <= 1;
            end
        end
    end

    always @(posedge clk or negedge rstn) begin
        if (!rstn) begin u_din <= 0; u_en <= 0; end
        else begin
            case (state) 
                WSEND: begin u_din <= {1'b1, latched_wdata, latched_addr}; u_en <= 1; end
                RSEND: begin u_din <= {1'b0, {DATA_WIDTH{1'b0}}, latched_addr}; u_en <= 1; end
                default: begin u_en <= 0; end
            endcase
        end
    end

    always @(*) begin
        if (state == LOCAL) sp_rvalid = lmem_rvalid;
        else if (state == RDATA) sp_rvalid = rdata_received;
        else sp_rvalid = 0;
    end
    
    assign sp_memrdata = (state == RDATA) ? (rdata_received ? latched_rdata : u_dout) :
                         (state == LOCAL) ? lmem_rdata : {DATA_WIDTH{1'b0}};
    assign sready = sp_ready && !sp_memwen && !sp_memren && (state == IDLE);
endmodule
\end{lstlisting}

\end{document}
